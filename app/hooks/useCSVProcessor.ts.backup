import { useState, useRef } from "react";
import Papa from "papaparse";
import type {
  TcgPlayerListing,
  ProcessingProgress,
  ProcessingSummary,
} from "../types/pricing";
import { ListingProcessor } from "../services/listingProcessor";

interface SummaryData {
  totalQuantity: number;
  totalAddQuantity: number;
  totals: {
    marketPrice: number;
    lowPrice: number;
    marketplacePrice: number;
    percentiles: { [key: string]: number };
  };
  totalsWithMarket: {
    marketPrice: number;
    percentiles: { [key: string]: number };
    quantityWithMarket: number;
  };
  daysToSellValues: number[];
  percentileDaysValues: { [key: string]: number[] };
}

export const useCSVProcessor = () => {
  const [isProcessing, setIsProcessing] = useState(false);
  const [progress, setProgress] = useState<ProcessingProgress | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [summary, setSummary] = useState<ProcessingSummary | null>(null);
  const isCancelledRef = useRef(false);
  const processStartTime = useRef<number>(0);

  const initializeSummaryData = (): SummaryData => {
    const summaryData: SummaryData = {
      totalQuantity: 0,
      totalAddQuantity: 0,
      totals: {
        marketPrice: 0,
        lowPrice: 0,
        marketplacePrice: 0,
        percentiles: {},
      },
      totalsWithMarket: {
        marketPrice: 0,
        percentiles: {},
        quantityWithMarket: 0,
      },
      daysToSellValues: [],
      percentileDaysValues: {},
    };

    // Initialize percentile tracking
    PERCENTILES.forEach((p) => {
      summaryData.totals.percentiles[`${p}th`] = 0;
      summaryData.totalsWithMarket.percentiles[`${p}th`] = 0;
      summaryData.percentileDaysValues[`${p}th`] = [];
    });

    return summaryData;
  };
  const addErrorMessage = (row: TcgPlayerListing, message: string): void => {
    const existingError = row["Error"] || "";
    row["Error"] = existingError ? `${existingError}; ${message}` : message;
  };

  const updateMarketplacePrice = (
    row: TcgPlayerListing,
    suggestedPrice: number
  ): void => {
    // Validate suggested price
    if (
      suggestedPrice === null ||
      suggestedPrice === undefined ||
      isNaN(suggestedPrice)
    ) {
      addErrorMessage(row, "Invalid suggested price value");
      return;
    }

    const marketPrice = Number(row["TCG Market Price"]) || 0;

    // Case 1: No market price available - use suggested price without enforcement
    if (marketPrice === 0) {
      row["TCG Marketplace Price"] = suggestedPrice.toString();
      addErrorMessage(
        row,
        "No TCG Market Price available - using suggested price without minimum price enforcement"
      );
      return;
    }

    // Case 2: Market price available - enforce minimum pricing
    const minimumPrice = marketPrice * (80 / 85) - 0.1;

    if (suggestedPrice < minimumPrice) {
      // Use minimum price when suggested price is too low
      row["TCG Marketplace Price"] = minimumPrice.toString();
      addErrorMessage(
        row,
        "Suggested price below minimum price - using minimum price"
      );
    } else {
      // Use suggested price when it meets minimum requirements
      row["TCG Marketplace Price"] = suggestedPrice.toString();
    }
  };

  const determineSuggestedPrice = (
    row: TcgPlayerListing,
    result: any
  ): { price: number | null; success: boolean } => {
    // Try API suggested price first
    if (result.suggestedPrice !== null && result.suggestedPrice !== undefined) {
      return { price: result.suggestedPrice, success: true };
    }

    // Fallback 1: Use TCG Low Price
    const lowPrice = Number(row["TCG Low Price"]) || 0;
    if (lowPrice > 0) {
      addErrorMessage(
        row,
        "Insufficient data for price suggestion - using lowest listing price"
      );
      return { price: lowPrice, success: true };
    }

    // Fallback 2: Use current marketplace price
    const currentMarketplacePrice = Number(row["TCG Marketplace Price"]) || 0;
    if (currentMarketplacePrice > 0) {
      addErrorMessage(
        row,
        "No price data available - using current marketplace price"
      );
      return { price: currentMarketplacePrice, success: true };
    }

    // No valid price found
    addErrorMessage(
      row,
      "No suggested price, low price, or current marketplace price available"
    );
    return { price: null, success: false };
  };

  const updateRowWithResults = (
    row: TcgPlayerListing,
    result: any,
    summaryData: SummaryData
  ): { success: boolean } => {
    if (result.error) {
      row["Error"] = result.error;
      return { success: false };
    }

    // Determine the suggested price using fallback hierarchy
    const { price: suggestedPrice, success: priceSuccess } =
      determineSuggestedPrice(row, result);

    if (!priceSuccess || suggestedPrice === null) {
      return { success: false };
    }

    // Safely convert suggestedPrice to string
    try {
      row["Suggested Price"] = suggestedPrice.toString();
    } catch (error) {
      addErrorMessage(row, "Invalid suggested price value");
      return { success: false };
    }

    row["Expected Days to Sell"] =
      result.expectedTimeToSellDays?.toString() || "";

    // Populate percentile data columns if available
    if (result.percentiles && result.percentiles.length > 0) {
      result.percentiles.forEach((percentileData: any) => {
        if (percentileData && typeof percentileData.price === "number") {
          row[`Price ${percentileData.percentile}th Percentile`] =
            percentileData.price.toFixed(2);
          if (percentileData.expectedTimeToSellDays !== undefined) {
            row[`Days to Sell ${percentileData.percentile}th Percentile`] =
              percentileData.expectedTimeToSellDays.toFixed(2);
          }
        }
      });
    }

    // Update TCG Marketplace Price based on pricing logic
    updateMarketplacePrice(row, suggestedPrice);

    // Update summary data
    updateSummaryData(row, summaryData);
    return { success: true };
  };
  const updateSummaryData = (
    row: TcgPlayerListing,
    summaryData: SummaryData
  ): void => {
    const { combinedQty } = getRowQuantities(row);

    const marketPrice = Number(row["TCG Market Price"]) || 0;
    const lowPrice = Number(row["TCG Low Price"]) || 0;
    const marketplacePrice = Number(row["TCG Marketplace Price"]) || 0;

    // Add to price totals
    summaryData.totals.marketPrice += marketPrice * combinedQty;
    summaryData.totals.lowPrice += lowPrice * combinedQty;
    summaryData.totals.marketplacePrice += marketplacePrice * combinedQty;

    // Track totals only for rows with market values
    const hasMarketValue = marketPrice > 0;
    if (hasMarketValue) {
      summaryData.totalsWithMarket.marketPrice += marketPrice * combinedQty;
      summaryData.totalsWithMarket.quantityWithMarket += combinedQty;

      // Add percentile totals only for rows with market values
      PERCENTILES.forEach((p) => {
        const percentilePrice = Number(row[`Price ${p}th Percentile`]) || 0;
        summaryData.totalsWithMarket.percentiles[`${p}th`] +=
          percentilePrice * combinedQty;
      });
    }

    // Collect days to sell for median calculation
    const expectedDays = Number(row["Expected Days to Sell"]) || 0;
    if (expectedDays > 0) {
      summaryData.daysToSellValues.push(expectedDays);
    }

    // Add percentile totals and collect days data
    PERCENTILES.forEach((p) => {
      const percentilePrice = Number(row[`Price ${p}th Percentile`]) || 0;
      const percentileDays = Number(row[`Days to Sell ${p}th Percentile`]) || 0;

      summaryData.totals.percentiles[`${p}th`] += percentilePrice * combinedQty;

      if (percentileDays > 0) {
        summaryData.percentileDaysValues[`${p}th`].push(percentileDays);
      }
    });
  };

  const createProcessingSummary = (
    file: File,
    percentile: number,
    totalRows: number,
    processed: number,
    skipped: number,
    errors: number,
    summaryData: SummaryData
  ): ProcessingSummary => {
    // Calculate medians for days to sell
    const medianDaysToSell = {
      expectedDaysToSell: calculateMedian(summaryData.daysToSellValues),
      percentiles: {} as { [key: string]: number },
    };

    PERCENTILES.forEach((p) => {
      medianDaysToSell.percentiles[`${p}th`] = calculateMedian(
        summaryData.percentileDaysValues[`${p}th`]
      );
    });

    const processingTime = Date.now() - processStartTime.current;
    const totalProcessed = processed + errors;
    const successRate =
      totalProcessed > 0 ? (processed / totalProcessed) * 100 : 0;

    return {
      totalRows,
      processedRows: processed,
      skippedRows: skipped,
      errorRows: errors,
      successRate,
      processingTime,
      fileName: file.name,
      percentileUsed: percentile,
      totalQuantity: summaryData.totalQuantity,
      totalAddQuantity: summaryData.totalAddQuantity,
      totals: summaryData.totals,
      totalsWithMarket: summaryData.totalsWithMarket,
      medianDaysToSell,
    };
  };

  const processCSV = async (file: File, percentile: number) => {
    setIsProcessing(true);
    isCancelledRef.current = false;
    setError(null);
    setSummary(null);
    processStartTime.current = Date.now();

    try {
      // Parse CSV
      const csvText = await file.text();
      const results = Papa.parse<TcgPlayerListing>(csvText, {
        header: true,
        skipEmptyLines: true,
      });
      const rows = results.data;
      let processed = 0;
      let skipped = 0;
      let errors = 0;

      const summaryData = initializeSummaryData();

      // Initialize new columns for all rows first
      rows.forEach((row) => {
        initializeRowColumns(row);
      });

      // Filter out rows that should be skipped before processing
      const filteredRows = rows.filter((row) => {
        if (shouldSkipRow(row)) {
          skipped++;
          return false;
        }

        // Track quantities for summary
        const { totalQty, addQty } = getRowQuantities(row);
        summaryData.totalQuantity += totalQty;
        summaryData.totalAddQuantity += addQty;

        return true;
      });

      // Initialize progress
      setProgress({
        current: 0,
        total: filteredRows.length,
        status: `Starting to process ${filteredRows.length} rows (${skipped} skipped)...`,
        processed: 0,
        skipped,
        errors: 0,
      });

      // Process filtered rows serially (one at a time)
      for (
        let rowIndex = 0;
        rowIndex < filteredRows.length && !isCancelledRef.current;
        rowIndex++
      ) {
        const row = filteredRows[rowIndex];

        // Update progress before processing
        setProgress({
          current: rowIndex + 1,
          total: filteredRows.length,
          status: `Processing row ${rowIndex + 1}/${filteredRows.length} (${
            row["Product Name"]
          })...`,
          processed,
          skipped,
          errors,
        });

        try {
          const result = await getSuggestedPrice(
            row["TCGplayer Id"],
            percentile
          );
          const { success } = updateRowWithResults(row, result, summaryData);

          if (success) {
            processed++;
          } else {
            errors++;
          }
        } catch (error: any) {
          row["Error"] = error?.message || "Processing error";
          errors++;
        }
      }

      // Check if cancelled before final steps
      if (isCancelledRef.current) {
        console.log("Processing cancelled by user");
        return;
      }

      // Final progress update
      setProgress({
        current: filteredRows.length,
        total: filteredRows.length,
        status: "Processing complete!",
        processed,
        skipped,
        errors,
      });

      // Create comprehensive summary
      const summary = createProcessingSummary(
        file,
        percentile,
        rows.length,
        processed,
        skipped,
        errors,
        summaryData
      );
      setSummary(summary);

      // Generate and download CSV with only the filtered (non-skipped) rows
      const filename = `${FILE_CONFIG.OUTPUT_PREFIX}${Date.now()}.csv`;
      downloadCSV(filteredRows, filename);
    } catch (error: any) {
      setError(error?.message || "Failed to process CSV");
    } finally {
      setIsProcessing(false);
    }
  };

  const handleCancel = () => {
    isCancelledRef.current = true;
    setIsProcessing(false);
    setProgress(null);
    setSummary(null);
  };

  return {
    isProcessing,
    progress,
    error,
    summary,
    processCSV,
    handleCancel,
    setError,
  };
};
